# C1 让自己习惯C++

## 01. 视C++为一个语言联邦(View c++ as a federation of langues)

C++主要由四个次语言组成：

- C
- Object-Oriented C++
- Template C++
- STL

当从一个次语言转向另一个次语言时，守则可能改变，例如，对内置（C-like）而言，`pass-by-value`通常比`pass-by-reference`更加有效，而对于`Object-Oriented C++`，由于用户定义的构造函数和析构函数的存在，`pass-by-reference-to-const`往往会更好。

> C++的高效编程守则视状况而变化，取决于你使用C++的哪一部分。

## 02. 尽量以`const, enum, inline`替换`#define`(Prefer consts, enums, and inlines to #defines)

例如，

```c++
#define ASPECT_RATIO 1.653
```

这里使用的名称`ASPECT_RATIO`在编译器处理源码前就被预处理器移走了，于是`ASPECT_RATIO`没有进入符号表（symbol table）内，因此，在编译错误中或debuger中不会显示`ASPECT_RATIO`，会给调试代码带来一定的麻烦。

我们应使用`const double AspectRatio = 1.653`作为代替，作为一个语言常量，`AspectRatio`显然会进入符号表，同时使用常量可能会比用`#define`产生更小量的码，因为预处理器会盲目的将宏名称替换成1.635，这可能导致出现多份的1.635。

在使用常量替换`#define`时，有两个特殊情况需要注意：

1. 定义常量指针时，要注意`const`的语义，如要定义一个指向常量的`char*-based`字符串的常量指针时，我们必须用两个`const`:

    ```c++
    const char* const pc = "Hello World";
    ```
    其中第一个`const`与`char*`一起表示指向的字符串是常量，而第二个`const`则表示这个指针是常量。

2. 在定义class专属常量时，为了将常量的作用域限制于class内，你必须让他成为一个成员，而为了常量至多保存为一份，所以你必须让他成为`static`成员。

    ```c++
    class CostEstimate{
    private:
        static const double FudgeFactor;
        //...
    };

    // 在实现文件中，而不是头文件中
    const double CostEstimate::FudgeFactor = 1.35;
    ```

    这种做法的唯一例外是当你在class的编译期间需要一个class常量值时，例如用这个class常量作为数组长度来定义一个数组时，我们可以用`the enum hack`来补偿做法，其理论为“一个属于枚举类型的数值可以权充int来使用”，如：

    ```c++
    clas GamePlayer{
    private:
        enum { NumTurns = 5}; // the enum hack
        int scores[NumTurns];
    }
    ```

另一个常见的`#define`的误用情况是以它实现宏：

```c++
#define CALL_WITH_MAX(a, b) f((a) > (b)? (a) : (b))
```

**无论什么时候使用宏时，必须为所有的实参加上小括号，否则某些人在调用宏的时候会遭遇麻烦。**

然而即使加上了小括号还是会出现一些麻烦，如：

```c++
int a = 5, b = 0, c = 10;
CALL_WITH_MAX(++a, b);    // a累加了2次
CALL_WITH_MAX(++a, c);    // a累加了1次
```

这时应该使用`template inline`函数：

```c++
template<typename T>
inline void callWithMax(const T &a, const T &b) {
    f(a > b? a : b);
}
```

> - 对于单纯常量，最好使用`const`对象或者使用`enums`替换`#define`
> - 对于形如函数的宏，最好使用`inline`函数替换`#define`

## 03. 尽可能的使用`const`(Use const whenever possible)

`const`允许你指定一个语义约束，而编译器会强制实施这项约束。

```c++
char s[] = "hello";
char *p = s;
const char *p = s;          // non-const pointer, non-const data
char * const p = s;         // non-const pointer, const data
const char * const p = s;   // const pointer, const data
```

可以用这一规则来识别`const`对指针的含义：

- 如果`const`出现在`*`号的左边，则表示被指物是常量。
- 如果`const`出现在`*`号的右边，则表示指针自身是常量。

`const`最具威力的用法是面对函数声明时的应用，在一个函数声明式内，`const`可以和函数返回值、各参数、函数本身（如果是成员函数）产生关联。

令函数返回一个常量值，往往可以降低因客户错误而造成的意外，而又不至于放弃安全性和高效性。

```c++
class Rational{...};
const Rational operator* (const Rational &lhs, const Rational &rhs);
```

返回一个`const Rational`可以避免下面的情况：

```c++
Rational a, b, c;
(a * b) = c;

// or

if (a * b = c) {}
```

对于`const`参数，除非你需要修改参数或`local`对象，否则请声明他们为`const`。

而`const`成员函数， 将`const`实施于成员函数的目的，是为了确认该成员函数可用于`const`对象上。

**两个成员函数如果只是常量性不同，是可以被重载的。**

```c++
class TextBlock {
public:
    const char& operator[](std::size_t pos) const {
        return text[pos];
    }
    char & operator[](std::size_t pos) {
        return text[pos];
    }
private:
    std::string text;
};

void print(const TextBlock& tb) {
    cout << tb[0]; //调用的是const TextBlock::operator[]
}

void print(TextBlock& tb) {
    cout << tb[0]; //调用的是TextBlock::operator[]
}
```

### `const`成员函数意味着什么？

- `bitwise constness`:

    > 成员函数只有在不更变对象的任何成员变量时，才能是`const`
    
    这种观点的好处是很容易侦测违反点：编译器只要寻找成员变量的赋值动作即可。然而，一个更改了“指针所指物”的成员函数虽不能算是`const`，但是如果只要指针隶属于对象，那么称此函数为`bitwise const`是不会引发编译错误的，例如：

    ```c++
    class CTextBlock {
    public:
        ...
        char& operator[](std::size_t pos) const {
            return pText[pos];
        }
    private:
        char *pText;
    };
    ```

    上面的代码虽不修改`pText`（即是`bitwise const`），但是他返回了`char &`,允许修改`pText`所指向的内容。

- `logical constness`

    > 一个`const`成员函数可以修改它所处理的对象内的某些bits，但只有在客户端侦测不出的情况才能如此。

    ```c++
    class CTextBlock {
    public:
        ...
        std::size_t length() const;
    private:
        char *pText;
        // mutable释放掉`non-static`成员变量的`bitwise constness`约束
        mutable std::size_t textLength;
        mutable bool lengthIsValid;
    };
    std::std::size CTextBlock::length() const {
        if (!lengthIsValid) {
            textLength = std::strlen(pText);
            lengthIsValid = true;
        }
        return textLength;
    }
    ```


在`const`和`not-const`成员函数实现相同功能时，可以使用`casting`重用代码：

```c++
class TextBlock {
public:
    const char& operator[](std::size_t pos) const {
        ...
        return pText[pos];
    }
    char &(std::size_t pos) {
        return const_cast<char&>(
            static_cast<const TextBlock>(*this)[pos]
        );
    }
}
```

上面代码使用了两次`casting`:

- 第一次`static_cast`是为`&this`添加`const`
- 第二次`const_case`是为了去除`const`

PS：往往`casting`是一个糟糕的想法。

**注意不要用`const`函数来调用`non-const`函数。**

> - 将某些东西声明为`const`可以帮助编译器检测错误用法。`const`可以被施加于任何作用域内的对象、函数参数、函数返回类型、成员函数本体。
> - 编译器强制实施`bitwise constness`，但是编写代码时应该使用`logical constness`。
> - 当`const`和`non-const`成员函数有着实质等价的实现时，令`non-const`版本调用`const`版本可以避免代码重复。